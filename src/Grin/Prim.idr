module Grin.Prim

import Data.Vect
import Data.List

import Core.TT
import Core.Core
import Core.CompileExpr
import Compiler.ANF

import Grin.Syntax

import public Grin.Prims.Functions
import public Grin.Prims.Constructors

||| Get the builtin type for an external function.
export
getGrinFFIType : CFType -> SimpleType
getGrinFFIType = \case
    CFUnit => UnitTy
    CFInt => Int64Ty
    CFUnsigned8 => Bits64Ty -- TODO: when grin gets more types make correct size.
    CFUnsigned16 => Bits64Ty
    CFUnsigned32 => Bits64Ty
    CFUnsigned64 => Bits64Ty
    CFString => StringTy
    CFDouble => DoubleTy
    CFChar => CharTy
    CFPtr => PtrTy
    CFGCPtr => PtrTy
    CFBuffer => PtrTy
    CFWorld => UnitTy -- Either Unit or Dead?
    CFFun _ _ => PtrTy
    CFIORes ty => getGrinFFIType ty
    CFStruct _ _ => PtrTy
    CFUser _ _ => PtrTy

getPrimTypeName : Constant -> String
getPrimTypeName = \case
    IntType => "Int"
    IntegerType => "Integer"
    Bits8Type => "Bits8"
    Bits16Type => "Bits16"
    Bits32Type => "Bits32"
    Bits64Type => "Bits64"
    StringType => "String"
    CharType => "Char"
    DoubleType => "Double"
    WorldType => "World"
    _ => "Unexpected Value instead of type"

||| Get the grin name of a prim function.
-- Note: These look very like the not quite idris
-- versions of these functions generated by idris
-- but they have no 'n' at the start
{- example definition of a primitive function
prim__add_Int x y =
    (CInt x') <- eval x
    (CInt y') <- eval y
    z <- _prim_int_add x' y'
    pure (CInt z)
-}
export
getPrimFnName : PrimFn arity -> String
getPrimFnName = \case
    Add ty => "prim__add_" ++ getPrimTypeName ty
    Sub ty => "prim__sub_" ++ getPrimTypeName ty
    Mul ty => "prim__mul_" ++ getPrimTypeName ty
    Div ty => "prim__div_" ++ getPrimTypeName ty
    Mod ty => "prim__mod_" ++ getPrimTypeName ty
    Neg ty => "prim__neg_" ++ getPrimTypeName ty
    ShiftL ty => "prim__shl" ++ getPrimTypeName ty
    ShiftR ty => "prim__shr" ++ getPrimTypeName ty

    BAnd ty => "prim__and_" ++ getPrimTypeName ty
    BOr ty => "prim__or_" ++ getPrimTypeName ty
    BXOr ty => "prim__xor_" ++ getPrimTypeName ty

    LT ty => "prim__lt_" ++ getPrimTypeName ty
    LTE ty => "prim__lte_" ++ getPrimTypeName ty
    EQ ty => "prim__eq_" ++ getPrimTypeName ty
    GT ty => "prim__gt_" ++ getPrimTypeName ty
    GTE ty => "prim__gte_" ++ getPrimTypeName ty

    StrLength => "prim__strLength"
    StrHead => "prim__strHead"
    StrTail => "prim__strTail"
    StrIndex => "prim__strIndex"
    StrCons => "prim__strCons"
    StrAppend => "prim__strAppend"
    StrReverse => "prim__strReverse"
    StrSubstr => "prim__strSubstr"

    DoubleExp => "prim__exp_Double"
    DoubleLog => "prim__log_Double"
    DoubleSin => "prim__sin_Double"
    DoubleCos => "prim__cos_Double"
    DoubleTan => "prim__tan_Double"
    DoubleASin => "prim__asin_Double"
    DoubleACos => "prim__acos_Double"
    DoubleATan => "prim__atan_Double"
    DoubleSqrt => "prim__sqrt_Double"
    DoubleFloor => "prim__floor_Double"
    DoubleCeiling => "prim__ceil_Double"

    Cast from to => "prim__cast_" ++ getPrimTypeName from ++ "_" ++ getPrimTypeName to
    BelieveMe => "prim__believe_me"
    Crash => "prim__crash"

||| Convert constant to a GRIN value.
export
getConstVal : Constant -> Val -- all these look very similar, generalise into one?
getConstVal = \case
    I i => primTagUnary "Int" $ LInt i
    BI i => primTagUnary "Integer" $ LInt $ cast i
    B8 i => primTagUnary "Bits8" $ LBits64 $ cast i
    B16 i => primTagUnary "Bits16" $ LBits64 $ cast i
    B32 i => primTagUnary "Bits32" $ LBits64 $ cast i
    B64 i => primTagUnary "Bits64" $ LBits64 $ cast i
    Str s => primTagUnary "String" $ LString s
    Ch c => primTagUnary "Char" $ LChar c
    Db d => primTagUnary "Double" $ LDouble d
    WorldVal => primTagNonary "World"
    IntType => primTagNonary "IntType"
    IntegerType => primTagNonary "IntegerType"
    Bits8Type => primTagNonary "Bits8Type"
    Bits16Type => primTagNonary "Bits16Type"
    Bits32Type => primTagNonary "Bits32Type"
    Bits64Type => primTagNonary "Bits64Type"
    StringType => primTagNonary "StringType"
    CharType => primTagNonary "CharType"
    DoubleType => primTagNonary "DoubleType"
    WorldType => primTagNonary "WorldType"

||| Get a case pattern for a primtive constant
export
getConstPat : Constant -> CasePat
getConstPat = \case
    I i => LitPat $ LInt i
    BI i => LitPat $ LInt $ cast i
    B8 i => LitPat $ LBits64 $ cast i
    B16 i => LitPat $ LBits64 $ cast i
    B32 i => LitPat $ LBits64 $ cast i
    B64 i => LitPat $ LBits64 $ cast i
    Str s => LitPat $ LString s
    Ch c => LitPat $ LChar c
    Db d => LitPat $ LDouble d
    WorldVal => NodePat (primTag "World") []
    IntType => NodePat (primTag "IntType") []
    IntegerType => NodePat (primTag "IntegerType") []
    Bits8Type => NodePat (primTag "Bits8Type") []
    Bits16Type => NodePat (primTag "Bits16Type") []
    Bits32Type => NodePat (primTag "Bits32Type") []
    Bits64Type => NodePat (primTag "Bits64Type") []
    StringType => NodePat (primTag "StringType") []
    CharType => NodePat (primTag "CharType") []
    DoubleType => NodePat (primTag "DoubleType") []
    WorldType => NodePat (primTag "WorldType") []

||| Unwrap a primitve value.
export
unwrapPrim : AConstAlt -> GrinVar -> Val
unwrapPrim (MkAConstAlt c _) v = case c of
    I _ => VTagNode (primTag "Int") [SVar v]
    BI _ => VTagNode (primTag "Integer") [SVar v]
    B8 _ => VTagNode (primTag "Bits8") [SVar v]
    B16 _ => VTagNode (primTag "Bits16") [SVar v]
    B32 _ => VTagNode (primTag "Bits32") [SVar v]
    B64 _ => VTagNode (primTag "Bits64") [SVar v]
    Str _ => VTagNode (primTag "String") [SVar v]
    Ch _ => VTagNode (primTag "Char") [SVar v]
    Db _ => VTagNode (primTag "Double") [SVar v]
    WorldVal => VVar v
    IntType => VVar v
    IntegerType => VVar v
    Bits8Type => VVar v
    Bits16Type => VVar v
    Bits32Type => VVar v
    Bits64Type => VVar v
    StringType => VVar v
    CharType => VVar v
    DoubleType => VVar v
    WorldType => VVar v

||| Primitive functions.
-- Todo: complete
export
prims : Ref NextId Int => Core (List GrinDef)
prims = do
    un <- traverse unary
        [ ("strTail", "String", "_prim_string_tail")
        ]
    unFT <- traverse unaryFromTo
        [ ("strLength", "String", "_prim_string_len", "Int")
        , ("strHead", "String", "_prim_string_head", "Int") -- Todo: change to Char when updated in grin
        ]
    bin <- traverse binary
        [ ("add_Int", "Int", "_prim_int_add")
        , ("add_Integer", "Integer", "_prim_int_add") -- for now just an Int to get it working
        , ("sub_Integer", "Integer", "_prim_int_sub")
        , ("mul_Integer", "Integer", "_prim_int_mul")
        , ("eq_Integer", "Integer", "_prim_int_eq")
        , ("lt_Integer", "Integer", "_prim_int_lt")
        , ("lte_Integer", "Integer", "_prim_int_le")
        , ("gt_Integer", "Integer", "_prim_int_gt")
        , ("gte_Integer", "Integer", "_prim_int_ge")
        ]
    believe_me <- do
        fromTy_ <- nextVar
        toTy_ <- nextVar
        arg <- nextVar
        pure $ MkDef (Grin "prim__believe_me") [fromTy_, toTy_, arg]
             $ Simple $ Fetch arg
    pure $ un ++ unFT ++ bin ++ [believe_me]
